# Нативный компилятор ReverseLang под архитектуру x64

// TODO Картинки в каждой секции. Можно даже от руки

##  Описание

Компилятор — программа, переводящая написанный на языке программирования текст в бинарный исполняемый файл.
В конкретном случае — с ReverseLang в ELF файл для архитектуры amd64. С синтаксисом ReverseLang можно ознакомится в 
[разделе с краткой справкой](#синтаксис-reverselang)

## Использование
### Сборка компилятора
0. Необходимо собрать фронтенд компилятора из репозитория [ReverseLang](https://github.com/foxidokun/ReverseLang), процесс сборки которого описан в [README](https://github.com/foxidokun/ReverseLang/blob/master/README.md).
1. Склонируйте репозиторий: `git clone https://github.com/foxidokun/x64_compiler`.
2. Скопируйте полученные бинарники `front` и `middle` в `bin/`.
3. Запустите скрипт `run.sh` из корневой директории проекта, передав два аргумента — файл с исходным кодом на языке Reverselang и путь, по которому сохранять собранный исполняемый файл.

> run.sh при необходимости соберет компилятор из исходников, после чего собирает программу на языке ReverseLang.

### Синтаксис ReverseLang
//TODO

## Теория

### Устройства компилятора

Компиляция происходит в несколько этапов:
> Фронтенд
1. Лексический анализ разбивает исходный код на логические кванты (лексемы) — числа, ключевые слова, имена.
2. Синтаксический анализ собирает из лексем синтаксические конструкции используя алгоритм рекурсивного спуска. 
3. В процессе рекурсивного спуска строится AST дерево (_abstract syntax tree_)`*`, которое является итоговым результатом фронтенда.

`*` — дерево, в котором внутренние вершины сопоставлены с операторами языка программирования, а листья — с соответствующими операндами.
> Промежуточный оптимизатор
* Оптимизатор принимает на вход AST дерево и пытается упростить его, вычисляя константные выражения.

> Бекенд
* Бекенд принимает оптимизированное AST дерево и конвертирует его в машинный код, выполняя `postorder` обход дерева.

##### Обоснование архитектуры компилятора
Такая архитектура позволяет переиспользовать общие куски при написании компиляторов других языков или под 
другие архитектуры. Так, например, компиляторы одного языка под `x64` и `arm` могут использовать общие
фронтенд и оптимизатор.

Подобная архитектура используется в семействе компиляторов `GCC`, а также в основанных на `llvm` компиляторах, правда в качестве 
внутреннего представления используется не AST дерево, а код на очень низкоуровневом языке.

### Устройство бекенда
Сам бекенд также имеет модульную структуру. Этап компиляции AST дерева разбит на два этапа: 
1. AST дерево компилируется в промежуточное представление (IR) — массив структур, являющихся ассемблерным кодом
для абстрактного стекового процессора (подробнее далее в секции IR).
2. После получения IR можно начать оптимизировать на ассемблерном уровне — убирать последовательные `push / pop`, например.
3. Далее этот IR превращается в инструкции для конкретной архитектуры процессора.

##### Обоснование архитектуры бекенда
Многие архитектуры процессоров построены на схожих принципах и имеют схожую систему команд — а значит конвертация AST в конкретные инструкции
для них будет общим местом. Создание явного IR позволяет переиспользовать эту часть, чем облегчает адаптацию компилятора
к новым архитектурам. При этом такой IR не универсален и теряет некоторый объем информации об исходном коде, а потому
он не является обязательной частью компилятора.

#### IR

В данном компиляторе в качестве IR используется связный список структур
```c++
    struct instruction_t {
        instruction_type_t type;            // Тип инструкции — push / add / call / etc
        struct {                            // Какие аргументы требуются инструкции
            unsigned char need_imm_arg: 1;  // - Константа
            unsigned char need_reg_arg: 1;  // - Регистр
            unsigned char need_mem_arg: 1;  // - Извлекается ли аргумент из памяти
        };

        unsigned char reg_num;              // Номер регистра-аргумента (если используется)
        uint64_t imm_arg;                   // Константный аргумент (если используется)

        size_t index;                       // Номер инструкции в IR
        instruction_t *next;                // Указатель на следующую структуру
    };
```

При этом IR рассчитан на абстрактный стековый процессор, а потому имеет следующие инструкции:

| Команда            | Действие                                                                                                        |
|--------------------|-----------------------------------------------------------------------------------------------------------------|
| `push reg/imm/mem` | Положить в стек значение из регистра, константу или из памяти по адресу `reg + imm`, где `reg` и `imm` опциональны. |
| `pop reg/mem`      | Достать из стека значение                                                                                       |
| `add/sub/mul/div`  | Арифметические операции с двумя верхними элементами на стеке (верхний элемент стека является правым операндом)  |
| `sqrt / sin / cos` | Арифметические операции с один элементом на стеке                                                               |
| `call/jmp/j?? imm` | Совершить переход на адрес (номер структуры), записанный в константном аргументе                                |
| `inp / out`        | Ввод / вывод верхнего числа со стека                                                                            |

Все операции поглощают свои операнды, и при наличии возвращаемого значения, кладут его на верхушку стека. 

### Структура ELF файла
// TODO Картинка
И хотя ELF файл может иметь сложную структуру, мы используем лишь примитивную 

### Сравнение времени работы