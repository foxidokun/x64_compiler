# Нативный компилятор ReverseLang под архитектуру x64

// TODO Картинки в каждой секции. Можно даже от руки

##  Описание

Компилятор — программа, переводящая написанный на языке программирования текст в бинарный исполняемый файл.
В конкретном случае — с ReverseLang в ELF файл для архитектуры amd64. С синтаксисом ReverseLang можно ознакомится в 
[разделе с краткой справкой](#синтаксис-reverselang)

## Использование
### Сборка компилятора

1. Склонируйте репозиторий: `git clone https://github.com/foxidokun/x64_compiler`
2. Соберите компилятор с помощью `make all`
3. Запустите скрипт `run.sh` из корневой директории проекта, передав два аргумента — файл с исходным кодом на языке Reverselang и путь, по которому сохранять собранный исполняемый файл. Например: `run.sh examples/... `

//TODO run.sh не должен собирать мой код, пусть он будет просто 

> run.sh при необходимости соберет компилятор из исходников, после чего собирает программу на языке ReverseLang.

### Синтаксис ReverseLang
//TODO

## Теория

### Устройства компилятора

Компиляция происходит в несколько этапов:
> Фронтенд
1. Лексический анализ разбивает исходный код на логические кванты (лексемы) — числа, ключевые слова, имена.
2. Синтаксический анализ собирает из лексем синтаксические конструкции используя алгоритм рекурсивного спуска. 
3. В процессе рекурсивного спуска строится абстрактное синтаксичдерево дерево (_abstract syntax tree_, AST)`*`, которое является итоговым результатом фронтенда.

звездочку перенести в 3

Не писать "AST дерево", а просто AST

Написать что в данной архитектуре AST является тут промежуточным представлением (IR)

`*` — дерево, в котором внутренние вершины сопоставлены с операторами языка программирования, а листья — с соответствующими операндами.
> Промежуточный оптимизатор (мидлеенд)
* Оптимизатор принимает на вход AST и пытается упростить его, вычисляя константные выражения.

> Бэкенд
* Бекенд принимает оптимизированное AST дерево и конвертирует его в машинный код, выполняя `postorder` обход дерева.

##### Обоснование архитектуры компилятора
Такая архитектура позволяет переиспользовать общие куски при написании компиляторов других языков или под 
другие архитектуры. Так, например, компиляторы одного языка под `x64` и `arm` могут использовать общие
фронтенд и оптимизатор.

Подобная архитектура используется в семействе компиляторов `GCC`, а также в основанных на `llvm` компиляторах, правда в качестве 
внутреннего представления используется не AST дерево, а линейное представление (LLVM IR).

### Устройство бекенда
Вместо IR = «промежкточное представление бэкенда (Backend IR)»

Но при этом в устройстве компилятора термин IR не использовать

Сам бекенд также имеет модульную структуру. Этап компиляции AST дерева разбит на два этапа: 
1. AST дерево компилируется в промежуточное представление (IR) — массив структур, являющихся ассемблерным кодом
для абстрактного стекового процессора (подробнее далее в секции IR).
2. После получения IR можно начать оптимизировать на ассемблерном уровне — убирать последовательные `push / pop`, например. Есть термин «backend optmisations» «Можно начать выполнять оптимизационные проходы»
3. Далее этот IR превращается в инструкции для конкретной архитектуры процессора.

##### Обоснование архитектуры бекенда
Многие архитектуры процессоров построены на схожих принципах и имеют схожую систему команд — а значит конвертация AST в конкретные инструкции
для них будет общим местом. Создание явного IR позволяет переиспользовать эту часть, чем облегчает адаптацию компилятора
к новым архитектурам. При этом такой IR не универсален и теряет некоторый объем информации об исходном коде, а потому
он не является обязательной частью компилятора.

При наличии IR можно легко написать и JIT и бинарный компилятор

// не терять информацию про код

#### IR

В данном компиляторе в качестве IR используется связный список структур
```c++
    struct instruction_t {
        instruction_type_t type;            // Тип инструкции — push / add / call / etc
        struct {                            // Какие аргументы требуются инструкции
            unsigned char need_imm_arg: 1;  // - Константа
            unsigned char need_reg_arg: 1;  // - Регистр
            unsigned char need_mem_arg: 1;  // - Извлекается ли аргумент из памяти
        };

        unsigned char reg_num;              // Номер регистра-аргумента (если используется)
        uint64_t imm_arg;                   // Константный аргумент (если используется)

        size_t index;                       // Номер инструкции в IR
        instruction_t *next;                // Указатель на следующую структуру
    };
```

При этом IR рассчитан на абстрактный стековый процессор, а потому имеет следующие инструкции:

| Команда            | Действие                                                                                                            |
|--------------------|---------------------------------------------------------------------------------------------------------------------|
| `push reg/imm/mem` | Положить в стек значение из регистра, константу или из памяти по адресу `reg + imm`, где `reg` и `imm` опциональны. |
| `pop reg/mem`      | Достать из стека значение                                                                                           |
| `add/sub/mul/div`  | Арифметические операции с двумя верхними элементами на стеке (верхний элемент стека является правым операндом)      |
| `sqrt / sin / cos` | Арифметические операции с один элементом на стеке                                                                   |
| `call/jmp/j?? imm` | Совершить переход на адрес (номер структуры), записанный в константном аргументе                                    |
| `inp / out`        | Ввод / вывод верхнего числа со стека                                                                                |

Все операции поглощают свои операнды, и при наличии возвращаемого значения, кладут его на верхушку стека. 


// Описать процесс загрузки stdlib

// Добавить в stdlib бинарника _start с выводом информационной строки о том, что это библиотека, а не бинарник

### Структура ELF файла
![img.png](images/elf_structure.png)

В результате компиляции получается ELF файл с минимальным 

### Сравнение времени работы